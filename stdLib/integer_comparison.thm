
Kind $lib__nat   type.
Import "integer_multiplication".



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                LESS                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Define $less_integer : $lib__integer -> $lib__integer -> prop by
  $less_integer ($posInt $zero) ($posInt ($succ N2));
  $less_integer ($posInt ($succ N1)) ($posInt ($succ N2)) :=
     $less_integer ($posInt N1) ($posInt N2);
  %
  $less_integer ($negSuccInt N1) ($posInt N2);
  %
  $less_integer ($negSuccInt ($succ N1)) ($negSuccInt $zero);
  $less_integer ($negSuccInt ($succ N1)) ($negSuccInt ($succ N2)) :=
     $less_integer ($negSuccInt N1) ($negSuccInt N2).

Theorem $less_integer_negSuccInt_left_step : forall A B,
  $less_integer ($negSuccInt A) B ->
  $less_integer ($negSuccInt ($succ A)) B.
induction on 1. intros L. case L (keep). search. search.
 apply IH to H1. search.

Theorem $less_integer_add_1_neg_left : forall N,
  $is_nat N ->
  $less_integer ($negSuccInt ($succ N)) ($negSuccInt N).
induction on 1. intros IsN. IsN: case IsN.
  %Subgoal 1
   search.
  %Subgoal 2
   apply IH to IsN. search.

Theorem $less_integer_posInt_right_step : forall A B,
  $less_integer A ($posInt B) -> $less_integer A ($posInt ($succ B)).
induction on 1. intros L. L: case L.
  %Subgoal 1
   search.
  %Subgoal 2
   apply IH to L. search.
  %Subgoal 3
   search.

Theorem $less_integer_posInt_both_step : forall A B,
  $less_integer ($posInt A) ($posInt B) ->
  $less_integer ($posInt ($succ A)) ($posInt ($succ B)).
induction on 1. intros L. L: case L.
  %Subgoal 1
   search.
  %Subgoal 2
   apply IH to L. search.

Theorem $less_integer_drop_succ_pos_left : forall A B,
  $less_integer ($posInt ($succ A)) B ->
  $less_integer ($posInt A) B.
induction on 1. intros L. L: case L. L': case L (keep).
  %Subgoal 1
   search.
  %Subgoal 2
   apply IH to L. search.

Theorem $less_integer_posInt : forall M N,
  $less_integer ($posInt M) N ->
  exists N', N = $posInt N'.
intros L. case L.
  %Subgoal 1
   search.
  %Subgoal 2
   search.

Theorem $less_integer_negSuccInt_is_nat : forall N1 N2,
  $less_integer N1 ($negSuccInt N2) -> $is_nat N2.
induction on 1. intros L. L: case L.
  %Subgoal 1
   search.
  %Subgoal 2
   apply IH to L. search.

Theorem $less_integer_pos_self : forall A,
  is_integer ($posInt A) ->
  $less_integer ($posInt A) ($posInt ($succ A)).
induction on 1. intros IsA. IsA: case IsA.
  %Subgoal 1
   search.
  %Subgoal 2
   apply IH to IsA. search.

Theorem $less_integer_neg_self : forall A,
  is_integer ($negSuccInt A) ->
  $less_integer ($negSuccInt ($succ A)) ($negSuccInt A).
induction on 1. intros IsA. IsA: case IsA.
  %Subgoal 1
   search.
  %Subgoal 2
   apply IH to IsA. search.

Theorem $less_integer_sum_pos_neg : forall A B C,
  $plus_integer ($posInt A) ($negSuccInt B) C ->
  is_integer ($posInt A) -> $less_integer C ($posInt A).
induction on 1. intros Plus IsA. Plus: case Plus.
  %Subgoal 1
   search.
  %Subgoal 2
   case IsA. backchain $less_integer_pos_self.
  %Subgoal 3
   case IsA. apply IH to Plus _. backchain $less_integer_posInt_right_step.

Theorem $less_integer_sum_neg_pos : forall A B C,
  $plus_integer ($negSuccInt A) ($posInt ($succ B)) C ->
  is_integer ($negSuccInt A) -> $less_integer ($negSuccInt A) C.
induction on 1. intros Plus IsA. Plus: case Plus.
  %Subgoal 1
   search.
  %Subgoal 2
   IsN1: case IsA. Plus': case Plus (keep).
     %Subgoal 2.1
      backchain $less_integer_neg_self.
     %Subgoal 2.2
      search.
     %Subgoal 2.3
      apply IH to Plus _. backchain $less_integer_negSuccInt_left_step.

Theorem $less_integer_sum_pos_pos : forall A B C,
  $plus_integer ($posInt ($succ A)) ($posInt B) C ->
  is_integer ($posInt A) -> $less_integer ($posInt A) C.
induction on 1. intros Plus IsA. Plus: case Plus. P': case Plus (keep).
  %Subgoal 1
   search.
  %Subgoal 2
   IsA: case IsA. apply IH to Plus _. search.

Theorem $less_integer_sum_neg_neg : forall A B C,
  $plus_integer ($negSuccInt A) ($negSuccInt B) C ->
  is_integer ($negSuccInt A) -> $less_integer C ($negSuccInt A).
induction on 1. intros Plus IsA. Plus: case Plus.
  %Subgoal 1
   search.
  %Subgoal 2
   case IsA. apply IH to Plus _. search.


Theorem extensibella-$-stdLib-$-less_integer_transitive :
  forall A B C,
    $less_integer A B -> $less_integer B C -> $less_integer A C.
induction on 2. intros LAB LBC. LBC: case LBC.
  %Subgoal 1
   case LAB. search.
  %Subgoal 2
   LAB': case LAB (keep).
     %Subgoal 2.1
      search.
     %Subgoal 2.2
      apply IH to LAB' LBC. search.
     %Subgoal 2.3
      search.
  %Subgoal 3
   case LAB.
     %Subgoal 3.1
      search.
     %Subgoal 3.2
      search.
  %Subgoal 4
   case LAB. search.
  %Subgoal 5
   LAB': case LAB. apply IH to LAB' LBC. search.


Theorem extensibella-$-stdLib-$-less_integer_not_eq : forall A,
  $less_integer A A -> false.
induction on 1. intros L. L: case L.
  %Subgoal 1
   apply IH to L.
  %Subgoal 2
   apply IH to L.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                               LESSEQ                               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Define $lesseq_integer : $lib__integer -> $lib__integer -> prop by
  $lesseq_integer ($posInt $zero) ($posInt $zero);
  $lesseq_integer ($posInt $zero) ($posInt ($succ N2));
  $lesseq_integer ($posInt ($succ N1)) ($posInt ($succ N2)) :=
     $lesseq_integer ($posInt N1) ($posInt N2);
  %
  $lesseq_integer ($negSuccInt N1) ($posInt N2);
  %
  $lesseq_integer ($negSuccInt $zero) ($negSuccInt $zero);
  $lesseq_integer ($negSuccInt ($succ N1)) ($negSuccInt $zero);
  $lesseq_integer ($negSuccInt ($succ N1)) ($negSuccInt ($succ N2)) :=
     $lesseq_integer ($negSuccInt N1) ($negSuccInt N2).

Theorem $lesseq_integer_posInt : forall M N,
  $lesseq_integer ($posInt M) N ->
  exists N', N = $posInt N'.
intros LEq. case LEq (keep). search. search. search.

Theorem $lesseq_negSuccInt_left_step : forall A B,
  $lesseq_integer ($negSuccInt A) B ->
  $lesseq_integer ($negSuccInt ($succ A)) B.
induction on 1. intros L. L: case L.
  %Subgoal 1
   search.
  %Subgoal 2
   search.
  %Subgoal 3
   search.
  %Subgoal 4
   apply IH to L. search.

Theorem extensibella-$-stdLib-$-lesseq_integer_less_or_eq :
  forall A B,
    $lesseq_integer A B -> $less_integer A B \/ A = B.
induction on 1. intros L. L: case L.
  %Subgoal 1
   search.
  %Subgoal 2
   search.
  %Subgoal 3
   Or: apply IH to L. case Or. search. search.
  %Subgoal 4
   search.
  %Subgoal 5
   search.
  %Subgoal 6
   search.
  %Subgoal 7
   Or: apply IH to L. case Or. search. search.

Theorem extensibella-$-stdLib-$-less_integer_lesseq : forall A B,
  $less_integer A B -> $lesseq_integer A B.
induction on 1. intros L. L: case L.
  %Subgoal 1
   search.
  %Subgoal 2
   apply IH to L. search.
  %Subgoal 3
   search.
  %Subgoal 4
   search.
  %Subgoal 5
   apply IH to L. search.

Theorem extensibella-$-stdLib-$-is_integer_lesseq : forall A,
  is_integer A -> $lesseq_integer A A.
 induction on 1. intros IsA. Is: case IsA.
  %Subgoal 1
   search.
  %Subgoal 2
   apply IH to Is. search.
  %Subgoal 3
   search.
  %Subgoal 4
   apply IH to Is. search.

Theorem extensibella-$-stdLib-$-lesseq_integer_transitive :
  forall A B C,
    $lesseq_integer A B -> $lesseq_integer B C -> $lesseq_integer A C.
induction on 2. intros LAB LBC. LBC': case LBC.
  %Subgoal 1
   search.
  %Subgoal 2
   case LAB. search. search.
  %Subgoal 3
   LAB': case LAB.
     %Subgoal 3.1
      search.
     %Subgoal 3.2
      apply IH to LAB' LBC'. search.
     %Subgoal 3.3
      search.
  %Subgoal 4
   case LAB. search. search. search.
  %Subgoal 5
   search.
  %Subgoal 6
   case LAB. search.
  %Subgoal 7
   LAB': case LAB. apply IH to LAB' LBC'. search.

Theorem extensibella-$-stdLib-$-less_lesseq_integer_transitive :
  forall A B C,
    $less_integer A B -> $lesseq_integer B C -> $less_integer A C.
induction on 2. intros LAB LBC. LBC: case LBC.
  %Subgoal 1
   search.
  %Subgoal 2
   L0SN2: assert $less_integer ($posInt $zero) ($posInt ($succ N2)).
   apply extensibella-$-stdLib-$-less_integer_transitive to LAB L0SN2.
   search.
  %Subgoal 3
   LAB: case LAB.
     %Subgoal 3.1
      search.
     %Subgoal 3.2
      apply IH to LAB LBC. search.
     %Subgoal 3.3
      search.
  %Subgoal 4
   LN1N2: assert $less_integer ($negSuccInt N1) ($posInt N2).
   apply extensibella-$-stdLib-$-less_integer_transitive to LAB LN1N2.
   search.
  %Subgoal 5
   search.
  %Subgoal 6
   LAB: case LAB. search.
  %Subgoal 7
   LAB: case LAB. apply IH to LAB LBC. search.

Theorem extensibella-$-stdLib-$-lesseq_less_integer_transitive :
  forall A B C,
    $lesseq_integer A B -> $less_integer B C -> $less_integer A C.
induction on 1. intros LAB LBC. LAB: case LAB.
  %Subgoal 1
   search.
  %Subgoal 2
   apply extensibella-$-stdLib-$-less_integer_transitive to _ LBC.
   search.
  %Subgoal 3
   LBC: case LBC. apply IH to LAB LBC. search.
  %Subgoal 4
   apply $less_integer_posInt to LBC. search.
  %Subgoal 5
   search.
  %Subgoal 6
   case LBC. search.
  %Subgoal 7
   LBC: case LBC.
     %Subgoal 7.1
      search.
     %Subgoal 7.2
      search.
     %Subgoal 7.3
      apply IH to LAB LBC. search.

Theorem extensibella-$-stdLib-$-less_sums : forall N1 N2 N3 Sum1 Sum2,
  $plus_integer N1 N2 Sum1 -> $plus_integer N1 N3 Sum2 ->
  is_integer N1 -> $less_integer N2 N3 ->
  $less_integer Sum1 Sum2.
induction on 1. intros PlusA PlusB IsN1 L. PlusA: case PlusA.
  %Subgoal 1
   case PlusB. search.
  %Subgoal 2
   PlusB: case PlusB.
     %Subgoal 2.1
      case IsN1. apply IH to PlusA PlusB _ _. search.
     %Subgoal 2.2
      case L.
     %Subgoal 2.3
      case L.
  %Subgoal 3
   case L. PlusB': case PlusB (keep). case IsN1.
   apply $less_integer_sum_pos_pos to PlusB _. search.
  %Subgoal 4
   PlusB: case PlusB.
     %Subgoal 4.1
      case IsN1. apply IH to PlusA PlusB _ _.
      backchain $less_integer_posInt_right_step.
     %Subgoal 4.2
      case IsN1. apply $less_integer_sum_pos_neg to PlusA _. search.
     %Subgoal 4.3
      case IsN1. case L. apply IH to PlusA PlusB _ _. search.
  %Subgoal 5
   case L. backchain $less_integer_sum_neg_pos.
  %Subgoal 6
   case L. case PlusB. search.
  %Subgoal 7
   PlusB: case PlusB.
     %Subgoal 7.1
      case L.
     %Subgoal 7.2
      case L. case IsN1. apply IH to PlusA PlusB _ _. search.
     %Subgoal 7.3
      case L.
  %Subgoal 8
   PlusB: case PlusB.
     %Subgoal 8.1
      search.
     %Subgoal 8.2
      search.
     %Subgoal 8.3
      search.
  %Subgoal 9
   PlusB: case PlusB.
     %Subgoal 9.1
      case IsN1. apply $less_integer_sum_neg_neg to PlusA _. search.
     %Subgoal 9.2
      case IsN1. LN6Sum2: apply IH to PlusA PlusB _ _.
      backchain $less_integer_negSuccInt_left_step.
     %Subgoal 9.3
      case IsN1. apply IH to PlusA PlusB _ _. search.

Theorem extensibella-$-stdLib-$-less_integer__add_positive :
  forall N1 N2 Base Sum,
    $less_integer Base N1 ->
    $lesseq_integer ($posInt $zero) N2 ->
    $plus_integer N1 N2 Sum -> $less_integer Base Sum.
induction on 1. intros L1 L2 Plus.
apply $lesseq_integer_posInt to L2. case L1 (keep).
  %Subgoal 1:  0 < N2
   case Plus. search.
  %Subgoal 2:  0 < N3 + 1
   case Plus. apply IH to H1 L2 H2. search.
  %Subgoal 3:  negSuccInt N3 < posInt N4
   case Plus. search. search.
  %Subgoal 4:  negSuccInt (succ N3) < -1
   case Plus. search. search.
  %Subgoal 5
   case Plus. search.
   LEq: assert $lesseq_integer ($posInt $zero) ($posInt N6).
           case H2. search. search. search.
   apply IH to H1 LEq H2. backchain $less_integer_negSuccInt_left_step.

Theorem extensibella-$-stdLib-$-lesseq_integer__add_positive :
  forall N1 N2 Base Sum,
    $lesseq_integer Base N1 ->
    $lesseq_integer ($posInt $zero) N2 ->
    $plus_integer N1 N2 Sum -> $lesseq_integer Base Sum.
induction on 1. intros L1 L2 Plus.
apply $lesseq_integer_posInt to L2. case L1 (keep).
  %Subgoal 1:  B = 0, N1 = 0
   case Plus. search.
  %Subgoal 2:  B = 0, N1 = posInt (succ N3)
   case Plus. search.
  %Subgoal 3:  B = posInt (succ N3), N1 = posInt (succ N4)
   case Plus. apply IH to H1 L2 H2. search.
  %Subgoal 4:  B = negSuccInt N3, N1 = posInt N4
   Pos: assert exists Sum', Sum = $posInt Sum'.
     case Plus. search. search.
   case Pos. search.
  %Subgoal 5:  B = negSuccInt 0, N1 = negSuccInt 0
   case L2.
     %Subgoal 5.1:  N2 = 0
      case Plus. search.
     %Subgoal 5.2
      case Plus. search.
  %Subgoal 6:  B = negSuccInt (succ N3), N1 = negSuccInt 0
   case L2.
     %Subgoal 6.1:  N2 = posInt 0
      case Plus. search.
     %Subgoal 6.2:  N2 = posInt (succ N4)
      case Plus. search.
  %Subgoal 7:  B = negSuccInt (succ N3), N1 = negSuccInt (succ N4)
   case Plus (keep).
     %Subgoal 7.1:  N2 = posInt 0
      search.
     %Subgoal 7.2:  N2 = posInt (succ N6)
      L': assert $lesseq_integer ($posInt $zero) ($posInt N6).
             case L2 (keep). case H2. search. search. search.
      apply IH to H1 L' H2. backchain $lesseq_negSuccInt_left_step.

Theorem extensibella-$-stdLib-$-less_integer__subtract_positive :
  forall N1 N2 Base Res,
    is_integer N1 -> is_integer N2 ->
    $less_integer N1 Base ->
    $lesseq_integer ($posInt $zero) N2 ->
    $minus_integer N1 N2 Res -> $less_integer Res Base.
intros IsN1 IsN2 L1 L2 M. P: case M.
  %1:  Res - 0 = Res
   search.
  %2:  N1 - ($succ N4) = Res
   Sub: assert forall A B C,
      $less_integer A Base -> $lesseq_integer B ($posInt $zero) ->
      $plus_integer B A C -> $less_integer C Base.
     induction on 3. clear L1 L2 P. intros L1 L2 P. P: case P.
       %2.1.1
        search.
       %2.1.2
        case L2.
       %2.1.3
        case L2.
       %2.1.4
        case L2.
       %2.1.5
        apply $less_integer_posInt to L1. search.
       %2.1.6
        apply $less_integer_drop_succ_pos_left to L1. search.
       %2.1.7
        L1': apply $less_integer_drop_succ_pos_left to L1.
        apply IH to L1' _ P. search.
       %2.1.8
        backchain $less_integer_negSuccInt_left_step.
       %2.1.9
        apply IH to L1 _ P.
        backchain $less_integer_negSuccInt_left_step.
   IsSN4: apply $is_integer_posInt_$$$$$_to_$$$$$_negSuccInt to IsN2.
   case IsSN4.
   P': apply extensibella-$-stdLib-$-plus_integer_comm to _ _ P.
   apply Sub to _ _ P'. search.
  %3:  N1 - ($negSuccInt N4) = Res
   case L2.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                              GREATER                               %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Define $greater_integer : $lib__integer -> $lib__integer -> prop by
  $greater_integer N1 N2 := $less_integer N2 N1.

Theorem extensibella-$-stdLib-$-greater_less_impossible :
  forall N1 N2,
    $greater_integer N1 N2 -> $less_integer N1 N2 -> false.
induction on 2. intros G L. L': case L.
  %Subgoal 1
   G': case G. case G'.
  %Subgoal 2
   G': case G. case G'. apply IH to _ L'.
  %Subgoal 3
   G': case G. case G'.
  %Subgoal 4
   G': case G. case G'.
  %Subgoal 5
   G': case G. case G'. apply IH to _ L'.

Theorem extensibella-$-stdLib-$-greater_integer__add_positive :
  forall N1 N2 Base Sum,
    $greater_integer N1 Base ->
    $lesseq_integer ($posInt $zero) N2 ->
    $plus_integer N1 N2 Sum -> $greater_integer Sum Base.
intros G L Plus. case G.
apply extensibella-$-stdLib-$-less_integer__add_positive to H1 L Plus.
search.

Theorem extensibella-$-stdLib-$-greater_integer_transitive :
  forall A B C,
    $greater_integer A B -> $greater_integer B C ->
    $greater_integer A C.
intros GAB GBC. LBA: case GAB. LCB: case GBC.
apply extensibella-$-stdLib-$-less_integer_transitive to LCB LBA.
search.

Theorem extensibella-$-stdLib-$-less_integer_flip_greater :
  forall N1 N2,
    $less_integer N1 N2 -> $greater_integer N2 N1.
induction on 1. intros L. L: case L.
  %Subgoal 1
   search.
  %Subgoal 2
   apply IH to L. search.
  %Subgoal 3
   search.
  %Subgoal 4
   search.
  %Subgoal 5
   apply IH to L. search.

Theorem extensibella-$-stdLib-$-greater_integer_flip_less :
  forall N1 N2,
    $greater_integer N1 N2 -> $less_integer N2 N1.
intros G. case G. search.

Theorem extensibella-$-stdLib-$-greater_integer_not_eq : forall N1,
  $greater_integer N1 N1 -> false.
intros G. L: case G.
apply extensibella-$-stdLib-$-less_integer_not_eq to L.

Theorem extensibella-$-stdLib-$-greater_plus_positive :
  forall N1 N2 Sum,
    is_integer N2 -> is_integer N1 -> $plus_integer N1 N2 Sum ->
    $greater_integer N2 ($posInt $zero) ->
    $greater_integer Sum N1.
induction on 3. intros IsN2 IsN1 P G. P: case P.
  %Subgoal 1
   search.
  %Subgoal 2
   IsN1: case IsN1. G': apply IH to _ _ P G. L: case G'. unfold.
   backchain $less_integer_posInt_both_step.
  %Subgoal 3
   L: case G. case L.
  %Subgoal 4
   L: case G. case L.
  %Subgoal 5
   L: case G. case L.
  %Subgoal 6
   search.
  %Subgoal 7
   IsN2: case IsN2. Is': case IsN2 (keep).
     %Subgoal 7.1
      case P. unfold. backchain $less_integer_add_1_neg_left.
      IsN3: apply $is_integer_negSuccInt_$$$$$_to_$$$$$_is_nat to IsN1.
      case IsN3. search.
     %Subgoal 7.2
      IsN3: case IsN1. G': apply IH to _ _ P _. unfold. L': case G'.
      backchain $less_integer_negSuccInt_left_step.
  %Subgoal 8
   L: case G. case L.
  %Subgoal 9
   case IsN1. G': apply IH to _ _ P G. L': case G'. search.



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                             GREATEREQ                              %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

Define $greatereq_integer : $lib__integer -> $lib__integer -> prop by
  $greatereq_integer N1 N2 := $lesseq_integer N2 N1.

Theorem extensibella-$-stdLib-$-is_integer_greatereq : forall A,
  is_integer A -> $greatereq_integer A A.
intros Is. apply extensibella-$-stdLib-$-is_integer_lesseq to Is.
search.

%N1 >= Base ->  N2 >= 0  ->  N1 + N2 = Sum  ->  Sum >= Base
Theorem extensibella-$-stdLib-$-greatereq_integer__add_positive :
  forall N1 N2 Base Sum,
    $greatereq_integer N1 Base ->
    $greatereq_integer N2 ($posInt $zero) ->
    $plus_integer N1 N2 Sum -> $greatereq_integer Sum Base.
intros G1 G2 Plus. case G1. case G2.
apply extensibella-$-stdLib-$-lesseq_integer__add_positive to
  H1 H2 Plus. search.

Theorem extensibella-$-stdLib-$-greatereq_integer_transitive :
  forall A B C,
    $greatereq_integer A B -> $greatereq_integer B C ->
    $greatereq_integer A C.
intros GAB GBC. LBA: case GAB. LCB: case GBC.
apply extensibella-$-stdLib-$-lesseq_integer_transitive to LCB LBA.
search.


Theorem extensibella-$-stdLib-$-greatereq_less_integer_false :
  forall N1 N2,
    $greatereq_integer N1 N2 -> $less_integer N1 N2 -> false.
induction on 2. intros GEq L. L: case L.
  %1:  0 < $succ N3
   GEq: case GEq. case GEq.
  %2:  $succ N3 < $succ N4
   GEq: case GEq. case GEq. apply IH to _ L.
  %3:  $negSuccInt N3 < $posInt N4
   GEq: case GEq. case GEq.
  %4:  $negSuccInt ($succ N3) < -1
   GEq: case GEq. case GEq.
  %5:  $negSuccInt ($succ N3) < $negSuccInt ($succ N4)
   GEq: case GEq. case GEq. apply IH to _ L.


Theorem extensibella-$-stdLib-$-less_lesseq_flip_false :
  forall N1 N2,
    $less_integer N1 N2 -> $lesseq_integer N2 N1 -> false.
induction on 1. intros L LEq. L: case L.
  %1:  0 < $succ N3
   case LEq.
  %2:  $succ N3 < $succ N4
   LEq: case LEq. apply IH to L LEq.
  %3:  $negSuccInt N3 < $posInt N4
   case LEq.
  %4:  $negSuccInt ($succ N3) < -1
   case LEq.
  %5:  $negSuccint ($succ N3) < $negSuccInt ($succ N4)
   LEq: case LEq. apply IH to L LEq.


Theorem extensibella-$-stdLib-$-greater_lesseq_integer_false :
  forall N1 N2,
    $greater_integer N1 N2 -> $lesseq_integer N1 N2 -> false.
intros G LEq. L: case G.
apply extensibella-$-stdLib-$-less_lesseq_flip_false to L LEq.


Theorem extensibella-$-stdLib-$-greatereq_integer_greater_or_eq :
  forall A B,
    $greatereq_integer A B -> $greater_integer A B \/ A = B.
intros GEq. LEq: case GEq.
Or: apply extensibella-$-stdLib-$-lesseq_integer_less_or_eq to LEq.
L: case Or.
  apply extensibella-$-stdLib-$-less_integer_flip_greater to L. search.
  search.


%combinations of <, <=, >, >= and addition, subtraction, multiplication, division, whatever

