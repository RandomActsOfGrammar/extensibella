Module compositionTest:list.


Prove_Ext_Ind compositionTest:host:is_expr,
              compositionTest:host:is_stmt.
%is_expr
 %nil
  search.
 %cons
  apply IH to R1. apply IH to R2. search.
 %head
  apply IH to R1. search.
 %tail
  apply IH to R1. search.
 %null
  apply IH to R1. search.
%is_stmt
 %listForeach
  apply IH to R2. apply IH1 to R3. search.


Add_Ext_Size compositionTest:host:evalExpr,
             compositionTest:host:evalStmt
        with listIterate G V X Body G'.


/*
  We don't obey any of the projection expectations, which is fine for
  testing the composition, but we get a lot of skips that way.
*/
Prove_Ext_Ind compositionTest:host:evalExpr,
              compositionTest:host:evalStmt
with forall G V X Body G',
       listIterate G V X Body G' with IsV: is_expr V.
%evalExpr
 %E-Nil
  skip.
 %E-Cons
  skip.
 %E-Head
  skip.
 %E-Tail
  skip.
 %E-Null-True
  skip.
 %E-Null-False
  skip.
%evalStmt
 %E-Foreach
  case IsS. apply ext_size_is_int_evalExpr to R3.
  apply ext_size_is_int_listIterate to R4.
  apply ext_size_pos_evalExpr to R3.
  apply ext_size_pos_listIterate to R4.
  apply plus_integer_is_integer to _ _ R2.
  L4: apply lt_plus_one to R1 _. Acc: case Acc.
  L2: assert N2 < N.
    Or: apply lt_left to R2 _ _. L': case Or.
      %N2 < N4
       apply less_integer_transitive to L' L4. search.
      %N2 = N4
       search.
  L3: assert N3 < N.
    Or: apply lt_right to R2 _ _ _. L': case Or.
      %N3 < N4
       apply less_integer_transitive to L' L4. search.
      %N3 = N4
       search.
  A2: apply Acc to _ L2. apply IH to R3 A2 _.
  A3: apply Acc to _ L3. LIP: apply IH5 to R4 A3 _. skip.
  skip.
%listIterate
 %LI-Nil
  search.
 %LI-Cons
  case IsV. Acc': case Acc (keep).
  apply ext_size_is_int_evalStmt to R2.
  apply ext_size_is_int_listIterate to R3.
  apply ext_size_pos_evalStmt to R2.
  apply ext_size_pos_listIterate to R3.
  assert <evalStmt {P}> ((X, V1)::G) Body G3.
    Or: apply lt_left to R1 _ _. L: case Or.
      %N2 < N
       A2: apply Acc' to _ L. apply IH1 to R2 A2 _. skip. search.
      %N2 = N
       apply IH4 to R2 Acc _. skip. search.
  assert <listIterate {P}> G3 V2 X Body G'.
    Or: apply lt_right to R1 _ _ _. L: case Or.
      %N3 < N
       A3: apply Acc' to _ L. apply IH2 to R3 A3 _. search.
      %N3 = N
       apply IH5 to R3 Acc _. search.
  search.


Theorem lookup_is : forall G X V,
  is_list (is_pair is_string is_expr) G -> lookup G X V -> is_expr V.
induction on 2. intros IsG L. L: case L.
  %Lkp-Here
   Is: case IsG. case Is. search.
  %Lkp-Later
   case IsG. apply IH to _ L1. search.


Prove compositionTest:host:evalExpr_unique,
      compositionTest:host:evalStmt_unique
with
  listIterate_unique : forall G V X Body GA GB,
    LIA : listIterate G V X Body GA ->
    LIB : listIterate G V X Body GB ->
    GA = GB
  on LIA * as IH_LI, LIB as IH_LIB,
  %these aren't actually mutually-inductive with the others
  %adding them is just for testing
  evalExpr_isValue : forall G E V G',
    IsE : is_expr E ->
    IsG : is_list (is_pair is_string is_expr) G ->
    Ev : evalExpr G E V G' ->
    is_expr V
  on Ev * as IH_IsE, IsE,
  evalExpr_isCtx : forall G E V G',
    IsE : is_expr E ->
    IsG : is_list (is_pair is_string is_expr) G ->
    Ev : evalExpr G E V G' ->
    is_list (is_pair is_string is_expr) G'
  on Ev * as IH_IsEC, IsE,
  evalStmt_isCtx : forall G S G',
    IsS : is_stmt S ->
    IsG : is_list (is_pair is_string is_expr) G ->
    Ev : evalStmt G S G' ->
    is_list (is_pair is_string is_expr) G'
  on Ev * as IH_IsS, IsS,
  listIterate_isCtx : forall G V X Body G',
    IsV : is_expr V ->
    IsX : is_string X ->
    IsBody : is_stmt Body ->
    IsG : is_list (is_pair is_string is_expr) G ->
    LI : listIterate G V X Body G' ->
    is_list (is_pair is_string is_expr) G'
  on LI * as IH_IsLI, IsV.
%ExtInd checks
 %evalExpr_unique
  skip.
 %evalStmt_unique
  skip.
 %listIterate_unique
  skip.
 %evalExpr_isValue
  search.
 %evalExpr_isCtx
  search.
 %evalStmt_isCtx
  search.
 %listIterate_isCtx
  search.
%evalExpr_unique
 %E-Nil
  case EvB. search.
 %E-Cons
  EvB: case EvB. apply IH to EvA1 EvB. apply IH to EvA2 EvB1. search.
 %E-Head
  EvB: case EvB. apply IH_EB to EvA1 EvB. search.
 %E-Tail
  EvB: case EvB. apply IH_EB to EvA1 EvB. search.
 %E-Null-True
  EvB: case EvB.
    %E-Null-True
     apply IH to EvA1 EvB. search.
    %E-Null-False
     apply IH to EvA1 EvB.
 %E-Null-False
  EvB: case EvB.
    %E-Null-True
     apply IH to EvA1 EvB.
    %E-Null-False
     apply IH to EvA1 EvB. search.
%evalStmt_unique
 %E-Foreach
  EvB: case EvB. apply IH to EvA1 EvB. apply IH_LIB to EvA2 EvB1.
  search.
%listIterate_unique
 %IL-Nil
  case LIB. search.
 %IL-Cons
  LIB: case LIB. apply IH_S to LIA1 LIB. apply IH_LI to LIA2 LIB1.
  search.
%evalExpr_isValue
 %E-Num
  case IsE. search.
 %E-Plus
  case IsE. IsV1: apply IH_IsE to _ _ Ev1. apply IH_IsEC to _ _ Ev1.
  IsV2: apply IH_IsE to _ _ Ev2. case IsV1. case IsV2.
  apply plus_integer_is_integer to _ _ Ev3. search.
 %E-True
  search.
 %E-False
  search.
 %E-And-False1
  search.
 %E-And-False2
  search.
 %E-And-True
  search.
 %E-Eq-True
  search.
 %E-Eq-False
  search.
 %E-StmtExpr
  case IsE. apply IH_IsS to _ _ Ev1. apply IH_IsE to _ _ Ev2. search.
 %E-Name
  apply lookup_is to _ Ev1. search.
 %E-Nil
  search.
 %E-Cons
  case IsE. apply IH_IsE to _ _ Ev1. apply IH_IsEC to _ _ Ev1.
  apply IH_IsE to _ _ Ev2. search.
 %E-Head
  case IsE. IsV: apply IH_IsE to _ _ Ev1. case IsV. search.
 %E-Tail
  case IsE. IsV: apply IH_IsE to _ _ Ev1. case IsV. search.
 %E-Null-True
  search.
 %E-Null-False
  search.
 %E-E-Q
  skip. %haven't done the projection constraints for this here
%evalExpr_isCtx
 %E-Num
  search.
 %E-Plus
  case IsE. apply IH_IsEC to _ _ Ev1. apply IH_IsEC to _ _ Ev2. search.
 %E-True
  search.
 %E-False
  search.
 %E-And-False1
  case IsE. apply IH_IsEC to _ _ Ev1. search.
 %E-And-False2
  case IsE. apply IH_IsEC to _ _ Ev1. apply IH_IsEC to _ _ Ev2. search.
 %E-And-True
  case IsE. apply IH_IsEC to _ _ Ev1. apply IH_IsEC to _ _ Ev2. search.
 %E-Eq-True
  case IsE. apply IH_IsEC to _ _ Ev1. apply IH_IsEC to _ _ Ev2. search.
 %E-Eq-False
  case IsE. apply IH_IsEC to _ _ Ev1. apply IH_IsEC to _ _ Ev2. search.
 %E-StmtExpr
  case IsE. apply IH_IsS to _ _ Ev1. apply IH_IsEC to _ _ Ev2. search.
 %E-Name
  search.
 %E-Nil
  search.
 %E-Cons
  case IsE. apply IH_IsEC to _ _ Ev1. apply IH_IsEC to _ _ Ev2. search.
 %E-Head
  case IsE. apply IH_IsEC to _ _ Ev1. search.
 %E-Tail
  case IsE. apply IH_IsEC to _ _ Ev1. search.
 %E-Null-True
  case IsE. apply IH_IsEC to _ _ Ev1. search.
 %E-Null-False
  case IsE. apply IH_IsEC to _ _ Ev1. search.
 %E-E-Q
  apply IH_IsEC to _ _ Ev2. skip. search.
%evalStmt_isCtx
 %E-Noop
  search.
 %E-Seq
  case IsS. apply IH_IsS to _ _ Ev1. apply IH_IsS to _ _ Ev2.
  apply IH_IsS to _ _ Ev3. search.
 %E-Seq5
  case IsS. apply IH_IsS to _ _ Ev1. apply IH_IsS to _ _ Ev2.
  apply IH_IsS to _ _ Ev3. apply IH_IsS to _ _ Ev4.
  apply IH_IsS to _ _ Ev5. search.
 %E-Assign
  case IsS. apply IH_IsE to _ _ Ev1. apply IH_IsEC to _ _ Ev1. search.
 %E-IfThenElse-True
  case IsS. apply IH_IsEC to _ _ Ev1. apply IH_IsS to _ _ Ev2. search.
 %E-IfThenElse-False
  case IsS. apply IH_IsEC to _ _ Ev1. apply IH_IsS to _ _ Ev2. search.
 %E-While-False
  case IsS. apply IH_IsEC to _ _ Ev1. search.
 %E-While-True
  case IsS. apply IH_IsEC to _ _ Ev1. apply IH_IsS to _ _ Ev2.
  apply IH_IsS to _ _ Ev3. search.
 %E-Foreach
  case IsS. apply IH_IsE to _ _ Ev1. apply IH_IsEC to _ _ Ev1.
  apply IH_IsLI to _ _ _ _ Ev2. search.
 %E-S-Q
  apply IH_IsS to _ _ Ev2. skip. search.
%listIterate_isCtx
 %IL-Nil
  search.
 %IL-Cons
  case IsV. apply IH_IsS to _ _ LI1. apply IH_IsLI to _ _ _ _ LI2.
  search.


Prove_Constraint compositionTest:host:evalExpr_forward.
skip. skip. skip. skip. skip.

Prove_Constraint compositionTest:host:evalExpr_back.
skip. skip. skip. skip. skip.

Prove_Constraint compositionTest:host:evalStmt_forward.
skip.

Prove_Constraint compositionTest:host:evalStmt_back.
skip.

Prove_Constraint compositionTest:host:expr_same.
case Hyp1. search.
case Hyp1. search.
case Hyp1. search.
case Hyp1. search.
case Hyp1. search.

Prove_Constraint compositionTest:host:stmt_same.
case Hyp1. search.


Prove compositionTest:typing:typeS_unchanged.
%T-Foreach
 search.


Prove compositionTest:typing:typePres,
      compositionTest:typing:typePres_S,
      compositionTest:typing:typePres_E_Ctx
with
   typePres_IL : forall V Ty G_T G_T' G_E X Body G_E' Z ZTy ZV,
     IsV : is_expr V ->
     VTy : typeE [] V (listTy Ty) ->
     Ty : typeS ((X, Ty)::G_T) Body G_T' ->
     LI : listIterate G_E V X Body G_E' ->
     Rel : (forall X XTy XV, lookup G_T X XTy -> lookup G_E X XV ->
               typeE [] XV XTy) ->
     LkpTy : lookup G_T Z ZTy ->
     LkpV : lookup G_E' Z ZV ->
     typeE [] ZV ZTy
   on LI as IH_LI.
%Ext_Ind validity for typePres_IL
 search.
%typePres
 %E-Nil
  case Ty. search.
 %E-Cons
  case IsE. Ty: case Ty. apply IH_E to _ Ty Ev1 _.
  apply IH_E to _ Ty1 Ev2 _. intros LXT LXV.
  apply IH_E_C to _ Ty Ev1 _ LXT LXV. search. search.
 %E-Head
  case IsE. Ty: case Ty. VTy: apply IH_E to _ Ty Ev1 _. case VTy.
  search.
 %E-Tail
  case IsE. Ty: case Ty. VTy: apply IH_E to _ Ty Ev1 _. case VTy.
  search.
 %E-Null-True
  case Ty. search.
 %E-Null-False
  case Ty. search.
%typePresS
 %E-Foreach
  case IsS. Ty: case Ty. VTy: apply IH_E to _ Ty Ev1 _.
  assert is_expr LV. skip.
  apply IH_LI to _ VTy Ty1 Ev2 _ LkpTy LkpV.
  intros LXT LXV. apply IH_E_C to _ Ty Ev1 _ LXT LXV. search. search.
%typePres_E_Ctx
 %E-Nil
  backchain Rel.
 %E-Cons
  case IsE. Ty: case Ty. apply IH_E_C to _ Ty1 Ev2 _ LkpTy LkpV.
  intros LXT LXV. apply IH_E_C to _ Ty Ev1 _ LXT LXV. search. search.
 %E-Head
  case IsE. Ty: case Ty. apply IH_E_C to _ Ty Ev1 _ LkpTy LkpV.
  search.
 %E-Tail
  case IsE. Ty: case Ty. apply IH_E_C to _ Ty Ev1 _ LkpTy LkpV.
  search.
 %E-Null-True
  case IsE. Ty: case Ty. apply IH_E_C to _ Ty Ev1 _ LkpTy LkpV.
  search.
 %E-Null-False
  case IsE. Ty: case Ty. apply IH_E_C to _ Ty Ev1 _ LkpTy LkpV.
  search.
%typePres_IL
 %IL-Nil
  backchain Rel.
 %IL-Cons
  case IsV. VTy: case VTy. apply IH_LI to _ VTy1  Ty LI2 _ LkpTy LkpV.
  intros LXT LXV. skip. search.


Add_Ext_Size compositionTest:typing:typeE,
             compositionTest:typing:typeS.


Prove_Ext_Ind compositionTest:typing:typeE,
              compositionTest:typing:typeS.
%typeE
 %T-Nil
  skip.
 %T-Cons
  skip.
 %T-Head
  skip.
 %T-Tail
  skip.
 %T-Null
  skip.
%typeS
 %T-Foreach
  skip.
